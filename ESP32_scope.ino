/*Development Log: 
Debugging and testing hardware. The ADC seems to have some issues; I might need a 1uF capacitor to filter out noise.

I tried not using the ESP32's IO to generate test signals directly, but instead used a variable resistor. 
The results seem to work normally, but if the ADC pin is left disconnected, it still shows a sine wave.
Suspected it might be a voltage issue.
It seems to be a pin issue. After switching to output through IO2, it worked normally.

Test more waveforms and attempt to remove noise (software), but it seems there is still hardware-induced noise.
It is unclear whether it is generated by the PWM output or by the ADC input.
 */
#include <driver/adc.h>
#include "esp_adc_cal.h"
#include <math.h>

const int pwmPin = 2;
const int adcPin = 36;  // ADC1_CH0
const int pwmFrequency = 10000; 
const int pwmResolution = 8;
const int waveformSteps = 200; 
const float waveFrequency = 2.0; 
const int persample = 5; 

esp_adc_cal_characteristics_t adc_chars;

void setup() {
  Serial.begin(115200);
  adc1_config_width(ADC_WIDTH_BIT_12);
  adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);
  ledcSetup(0, pwmFrequency, pwmResolution);
  ledcAttachPin(pwmPin, 0);
  esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, 1100, &adc_chars);
}

int movingAverage(int newValue) {
  static int values[persample];
  static int index = 0;
  static long sum = 0;
  static bool isFull = false;

  sum = sum - values[index] + newValue;
  values[index] = newValue;
  index = (index + 1) % persample;

  if (index == 0) {
    isFull = true;
  }

  int average;
  if (isFull) {
    average = sum / persample;
  } else {
    average = sum / (index + 1);
  }

  return average;
}

void genWave(int waveformType) {
  int stepDelay = 1000000 / (waveFrequency * waveformSteps) - 200; 

  for (int i = 0; i < waveformSteps; i++) {
    int pwmValue;
    float phase = (float)i / waveformSteps;

    if (waveformType == 0) { 
      if (phase < 0.5) {
        pwmValue = 255;
      } else {
        pwmValue = 0;
      }
    } else if (waveformType == 1) { 
      if (phase < 0.5) {
        pwmValue = (int)(phase * 510);
      } else {
        pwmValue = (int)((1 - phase) * 510);
      }
    } else { 
      float sineValue = sin(2 * PI * phase);
      pwmValue = (int)((sineValue + 1) * 127.5);
    }
    
    ledcWrite(0, pwmValue);

    int adcValue = 0;
    for (int j = 0; j < persample; j++) {
      adcValue = movingAverage(adc1_get_raw(ADC1_CHANNEL_0));
      delayMicroseconds(20); 
    }

    uint32_t voltage = esp_adc_cal_raw_to_voltage(adcValue, &adc_chars);
    
    Serial.print(pwmValue);
    Serial.print(",");
    Serial.println(voltage);

    if (stepDelay > 0) {
      delayMicroseconds(stepDelay);
    }
  }
}

void loop() {
  
  Serial.println("Square Wave");
  genWave(0);  
  delay(100); 

  Serial.println("Triangle Wave");
  genWave(1); 
  delay(100); 

  Serial.println("Sine Wave");
  genWave(2);  
  delay(100); 
}
